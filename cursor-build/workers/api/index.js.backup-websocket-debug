/**
 * CryptoGuard API v2.0 - Enhanced with AlertEngine
 * Real-time crypto alerts with intelligent monitoring
 */

// Import Durable Objects
export { WebSocketManager } from '../durable-objects/WebSocketManager.js';
export { AlertEngine } from '../durable-objects/AlertEngine.js';

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = url.pathname;

    // CORS headers
    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    };

    // Handle preflight requests
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    try {
      // Main API info
      if (path === '/') {
        return new Response(JSON.stringify({
          message: "CryptoGuard API v2.0 - Enhanced AlertEngine System!",
          lunarcrush_connected: env.LUNARCRUSH_API_KEY ? "Yes" : "No",
          websocket_enabled: "Yes",
          alert_engine: "Active",
          endpoints: {
            health: "/health",
            crypto_list: "/crypto/list",
            crypto_detail: "/crypto/{symbol}",
            websocket: "/realtime",
            alert_websocket: "/alerts",
            stats: "/stats"
          }
        }), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }

      // Health check
      if (path === '/health') {
        return new Response(JSON.stringify({
          status: "healthy",
          api_key_configured: env.LUNARCRUSH_API_KEY ? "Yes" : "No",
          websocket_ready: "Yes",
          alert_engine: "Active",
          timestamp: new Date().toISOString()
        }), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }

      // Crypto data endpoints
      if (path.startsWith('/crypto')) {
        const { handleCryptoRequest } = await import('./routes/crypto.js');
        return await handleCryptoRequest(request, env, corsHeaders);
      }

      // Enhanced AlertEngine WebSocket
      if (path === '/alerts') {
        if (request.headers.get('Upgrade') !== 'websocket') {
          return new Response('Expected WebSocket upgrade', { status: 426 });
        }

        const alertEngineId = env.ALERT_ENGINE.idFromName('main-alert-engine');
        const alertEngine = env.ALERT_ENGINE.get(alertEngineId);
        
        return await alertEngine.handleWebSocket(request);
      }

      // Legacy WebSocket endpoint (redirect to /alerts)
      if (path === '/realtime') {
        if (request.headers.get('Upgrade') !== 'websocket') {
          return new Response(JSON.stringify({
            message: "WebSocket endpoint",
            upgrade_to: "/alerts",
            note: "Use /alerts for enhanced AlertEngine features"
          }), {
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }

        // Redirect to enhanced AlertEngine
        const alertEngineId = env.ALERT_ENGINE.idFromName('main-alert-engine');
        const alertEngine = env.ALERT_ENGINE.get(alertEngineId);
        
        return await alertEngine.handleWebSocket(request);
      }

      // Alert Engine stats - Fixed implementation
      if (path === '/stats') {
        try {
          const alertEngineId = env.ALERT_ENGINE.idFromName('main-alert-engine');
          const alertEngine = env.ALERT_ENGINE.get(alertEngineId);
          
          // Create a dummy request to get stats via the Durable Object
          const statsRequest = new Request('http://internal/stats', {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
          });
          
          const statsResponse = await alertEngine.fetch(statsRequest);
          const statsData = await statsResponse.json();
          
          return new Response(JSON.stringify({
            alert_engine: statsData,
            api_version: "2.0",
            timestamp: new Date().toISOString()
          }), {
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        } catch (error) {
          // Fallback stats if Durable Object isn't responding
          return new Response(JSON.stringify({
            alert_engine: {
              status: "initializing",
              active_connections: 0,
              total_alerts: 0,
              last_check: null,
              note: "AlertEngine starting up"
            },
            api_version: "2.0",
            timestamp: new Date().toISOString()
          }), {
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }
      }

      // 404 for unknown routes
      return new Response(JSON.stringify({
        error: "Not Found",
        available_endpoints: ["/", "/health", "/crypto/list", "/crypto/{symbol}", "/alerts", "/stats"]
      }), {
        status: 404,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });

    } catch (error) {
      console.error('API Error:', error);
      return new Response(JSON.stringify({
        error: "Internal Server Error",
        message: error.message
      }), {
        status: 500,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }
  },

  // Scheduled function to check alerts every 30 seconds
  async scheduled(controller, env, ctx) {
    try {
      const alertEngineId = env.ALERT_ENGINE.idFromName('main-alert-engine');
      const alertEngine = env.ALERT_ENGINE.get(alertEngineId);
      
      // Trigger alert check via internal request
      const checkRequest = new Request('http://internal/check-alerts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });
      
      await alertEngine.fetch(checkRequest);
      
      console.log('Scheduled alert check completed');
    } catch (error) {
      console.error('Scheduled function error:', error);
    }
  }
};
